<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>ScribblerToo – Pressure + iPad</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#0b0b0b; color:#eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    header { display:flex; gap:10px; flex-wrap:wrap; align-items:center; padding: env(safe-area-inset-top) 10px 8px 10px; position:sticky; top:0; background:#141414; border-bottom:1px solid #222; z-index:2; }
    header > * { background:#1b1b1b; border:1px solid #2a2a2a; border-radius:10px; color:#eee; padding:6px 10px; }
    header label { border:none; padding:0; margin-right:6px; opacity:.8; }
    button { cursor:pointer; }
    main { padding: 8px; }
    #wrap { position: relative; width: 100%; max-width: min(95vw, 95vh); margin: 0 auto; }
    canvas { width: 100%; height: auto; touch-action: none; background: #0e0e0e; border:1px solid #222; border-radius: 12px; }
    .hint { text-align:center; opacity:.7; font-size: 12px; margin-top:6px; }
    .pill { padding:2px 8px; border-radius:999px; border:1px solid #333; background:#111; }
  </style>
</head>
<body>
  <header>
    <span class="pill">ScribblerToo • Pressure</span>
    <label for="color">Color</label><input type="color" id="color" value="#ff4d4d">
    <label for="width">Base width</label><input type="range" id="width" min="1" max="40" value="8">
    <label for="alpha">Opacity</label><input type="range" id="alpha" min="0.05" max="1" step="0.01" value="1">
    <button id="undo">Undo</button>
    <button id="redo">Redo</button>
    <button id="clear">Clear</button>
    <button id="save">Save PNG</button>
  </header>
  <main>
    <div id="wrap">
      <canvas id="canvas" width="1500" height="1500"></canvas>
    </div>
    <div class="hint">Draw with mouse, touch, or Apple Pencil. Lines within 100px of your current endpoint may connect to a random point from earlier paths.</div>
  </main>

  <script>
  (() => {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const colorEl = document.getElementById('color');
    const widthEl = document.getElementById('width');
    const alphaEl = document.getElementById('alpha');
    const undoEl = document.getElementById('undo');
    const redoEl = document.getElementById('redo');
    const clearEl = document.getElementById('clear');
    const saveEl = document.getElementById('save');

    let paths = [];
    let redoStack = [];
    let current = null;
    let drawing = false;

    function beginPathAt(x, y, p=1) {
      drawing = true;
      current = {
        color: colorEl.value,
        baseWidth: parseFloat(widthEl.value),
        alpha: parseFloat(alphaEl.value),
        points: [{x, y, p}],
        bbox: {minx:x, miny:y, maxx:x, maxy:y}
      };
    }

    function extendPathTo(x, y, p=1) {
      if (!drawing || !current) return;
      const last = current.points[current.points.length-1];
      const pt = {x,y,p};
      current.points.push(pt);
      const b = current.bbox;
      if (x<b.minx) b.minx=x; if (y<b.miny) b.miny=y; if (x>b.maxx) b.maxx=x; if (y>b.maxy) b.maxy=y;

      const w = Math.max(0.5, current.baseWidth * (p || 1));
      ctx.save();
      ctx.globalAlpha = current.alpha;
      ctx.strokeStyle = current.color;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = w;
      ctx.beginPath();
      ctx.moveTo(last.x, last.y);
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.restore();

      connectNearby({x:x, y:y});
    }

    function endPath() {
      if (!drawing || !current) return;
      if (current.points.length > 1) {
        paths.push(current);
        redoStack.length = 0;
      }
      current = null;
      drawing = false;
    }

    function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

    function connectNearby(lastPt) {
      const R = 100, R2 = R*R;
      for (let i=0;i<paths.length;i++) {
        const path = paths[i];
        const b = path.bbox;
        if (lastPt.x < b.minx - R || lastPt.x > b.maxx + R || lastPt.y < b.miny - R || lastPt.y > b.maxy + R) continue;
        let qualifies = false;
        for (let j=0;j<path.points.length;j++) {
          if (dist2(lastPt, path.points[j]) <= R2) { qualifies = true; break; }
        }
        if (qualifies) {
          const idx = Math.floor(Math.random()*path.points.length);
          const rnd = path.points[idx];
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(lastPt.x, lastPt.y);
          ctx.lineTo(rnd.x, rnd.y);
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    function redrawAll() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for (const s of paths) {
        if (!s.points || s.points.length<2) continue;
        ctx.save();
        ctx.globalAlpha = s.alpha;
        ctx.strokeStyle = s.color;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        for (let i=1;i<s.points.length;i++) {
          const a = s.points[i-1], b = s.points[i];
          const w = Math.max(0.5, s.baseWidth * (b.p || 1));
          ctx.lineWidth = w;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    undoEl.onclick = () => { if (paths.length) { redoStack.push(paths.pop()); redrawAll(); } };
    redoEl.onclick = () => { if (redoStack.length) { paths.push(redoStack.pop()); redrawAll(); } };
    clearEl.onclick = () => { paths = []; redoStack = []; current=null; drawing=false; ctx.clearRect(0,0,canvas.width,canvas.height); };
    saveEl.onclick = () => {
      const a = document.createElement('a');
      a.download = 'scribblertoo.png';
      a.href = canvas.toDataURL('image/png');
      a.click();
    };

    function getXY(evt) {
      const rect = canvas.getBoundingClientRect();
      return { x: (evt.clientX - rect.left) * (canvas.width / rect.width),
               y: (evt.clientY - rect.top)  * (canvas.height / rect.height) };
    }
    function pressureOf(evt) {
      let p = 1;
      if (typeof evt.pressure === 'number' && evt.pressure > 0) p = evt.pressure;
      if (evt.pointerType === 'mouse' && (!evt.pressure || evt.pressure === 0)) p = 1;
      return Math.max(0.15, Math.min(1, p));
    }

    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      canvas.setPointerCapture(e.pointerId);
      const {x,y} = getXY(e);
      beginPathAt(x, y, pressureOf(e));
    }, {passive:false});

    canvas.addEventListener('pointermove', (e) => {
      if (!drawing) return;
      e.preventDefault();
      const {x,y} = getXY(e);
      extendPathTo(x, y, pressureOf(e));
    }, {passive:false});

    function finish(e){ endPath(); try{ canvas.releasePointerCapture(e.pointerId); }catch{} }
    canvas.addEventListener('pointerup', (e) => { e.preventDefault(); finish(e); }, {passive:false});
    canvas.addEventListener('pointercancel', (e) => { e.preventDefault(); finish(e); }, {passive:false});
    document.body.addEventListener('touchmove', (e) => { if (e.target === canvas) e.preventDefault(); }, {passive:false});

    // Persist prefs
    const LS='st-pressure-v1';
    function savePrefs(){
      const prefs = { color: colorEl.value, width: widthEl.value, alpha: alphaEl.value };
      localStorage.setItem(LS, JSON.stringify(prefs));
    }
    function loadPrefs(){
      try{
        const p = JSON.parse(localStorage.getItem(LS)||'{}');
        if(p.color) colorEl.value = p.color;
        if(p.width) widthEl.value = p.width;
        if(p.alpha) alphaEl.value = p.alpha;
      }catch{}
    }
    [colorEl,widthEl,alphaEl].forEach(el => el.addEventListener('change', savePrefs));
    loadPrefs();
  })();
  </script>
</body>
</html>
